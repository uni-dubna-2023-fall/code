# Python: некоторые встроенные возможности

## list, dict comprehensions
Это специльная возможность формировать списки и словари на лету из объектов, по которым можно итерироваться.

Например, пусть мы имеем список имен. Мы хотим создать список объектов типа `Student` инициализированных именами.
```python
class Student:
    def __init__(self, name):
        self.name = name

# список имен
names = ["John Doe", "Alice Reed", "Brittany White"]

# список студентов
students = [Student(name) for name in names]

# из исходного списка имен можно взять не все, а только те, которые удовлетворяют некоторому условию
short_students = [Student(name) for name in names if len(name.split()[0]) <= 5]
```

Примерно так же можно создавать и словари, только синтаксис немного отличается
```python
# словарь из имен и объектов
students_dict = {name: Student(name) for name in names}

# словарь из имен и длин имен
name_lenghts = {name: len(name.split()[0]) for name in names}
```

## *args, **kwargs опциональные и именованные аргументы
Часто, когда будете смотреть код на Python, вы увидете что функции вызываются примерно вот так `foo(*args)` или `bar(a, b, **kwargs)`. Давайте посмотрим как этим пользоваться.

Создадим функцию принимающую произвольное количество аргументов, которая печатает первый аргумент и возвращает количество аргументов
```python
def foo(*args):
    if len(args) > 0:
        print(args[0])
    return len(args)

n = foo("Hello", "world")
print(n)
```
`foo("Hello", "world")` напечатает "Hello" и вернет 2. Внутри такой функции переменная args это кортеж (tuple), к элементам которого можно обращаться по индексу `args[0]` или `args[1]`.

Опциональные аргументы можно передавать вот так
```python
l = ["a", "b", "c"]
foo(*l)
```
В таком случае количество аргументов, будет равно количеству элементов в списке. Функция напечает `a` и вернет 3.

Если вы хотите, чтобы у функции было минимум два аргумента, то используйте конструкцию вида
```python
def foo(a, b, *args):
    print(a + b)
    return len(args)

n = foo(1, 2, 5)
print(n)
```
`func(1, 2, 5)` напечатает 3 и вернет 1. `func(1, 2, 5, 10)` напечатает 3 и вернет 2.

Именованные аргументы позволяют передавать их в произвольном порядке и задавать для аргументов значения по умолчанию (дефолтные значения). А поскольку у именованных аргументов есть дефолтное значение, то эти аргументы являются необязательным (опциональными). Именованные аргументы должны идти в определении функции после неименованных. Например
```python
def foo(first_name, second_name="Doe", profession="Engineer"):
    print(f"First Name: {first_name} Second Name: {second_name} Profession: {profession}")

# только один аргумент, остальные по умолчанию
foo("John")
# второй аргумент будет использован для именованного аргумента
# second_name (он хоть и именованный, но второй по очереди)
foo("Alice", "Reed")
# переданы именованные аргументы
foo("Alice", second_name="Reed", profession="Secretary")
# у именованных аргументов понядок не важен, если вы передаете имена
foo("Alice", profession="Secretary", second_name="Reed")
```

Если вы заранее не знаете какие именованные аргументы у вас будут, вы можете определять функцию так
```python
def foo(**kwargs):
    if "first_name" in kwargs:
        print(kwargs["first_name"])

foo(first_name="Alice", second_name="Reed")
```

Именованные аргументы можно передавать и так
```python
d = {"first_name": "Alice Reed", "second_name": "John Doe"}
foo(**d)
```

## Некоторые специальные методы
В Python есть такое понятие как *magic* методы. Разные типы (классы) могут реализовывать разные *magic* методы. Для того чтобы узнать вообще весь список доступных атрубутов (методы тоже являются атрибутами) у объекта, вы можете использовать встроенную функцию `dir`.

Например
```python
d = {"Alice": "Reed"}
print(dir(d))
```
Этот код напечатает вам вот такой длинный список
```
['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
```
Здесь те методы, которые начинаются с `__` (двух нижних подчеркиваний), это и есть *magic* методы. Вы можете отнаследовать ваш класс от какого-нибудь базового типа, например `dict` реализовать какие-то из этих методов.

Давайте рассмотрим пример реализации метода `__len__`. Этот метод у объекта вызывается, когда вы используете встроенную функцию `len()`.
```python
class MyDict(dict):
    def __len__(self):
        return super().__len__() + 1

d = {"Alice": "Reed", "John": "Doe"}
# у обычного словаря len вернет количество ключей в словаре
print(len(d))

# в нашей реализации len вернет на один больше
my_d = MyDict(**d)
print(len(my_d))
```

Вы можете также попробовать реализовать методы `__add__`, `__str__`, `__getattr__` и так далее.

## Контекстные менеджеры
Иногда вы работаете с объектами, которые после использования нужно определенным образом обработать. Например, когда вы работаете с файлами, нужно открыть файл, прочитать/записать данные и потом закрыть. То же самое с клиентскими соединениями к базам данных, после использования соединение нужно закрыть.

Такую обработку после использования удобно делать с помощью контекстного менеджера (см. ключевое слово with). В этом случае вам просто не нужно помнить о послеобработке. Это произойдет автоматически. Нужно только, чтобы у контекстного менеджера были реализованы определенные *magic* методы (`__enter__`, `__exit__`).

Давайте рассмотрим пример
```python
f = open("tmp.txt", "w")
f.write("Hello world\n")
f.close()
```
То же самое можно сделать вот так
```python
with open("tmp2.txt", "w") as f:
    f.write("Hello world\n")
```
Как видите во втором случае вам не нужно вызывать `close` у файлового объекта.

Пример реализации контекстного менеджера (попробуйте поиграть с этим кодом и разобраться)
```python
class MyContext:
    def __init__(self):
        print("__init__ called")
        self.state = "closed"
        self.print_state("inside __init__")

    # этот метод нужен, чтобы сделать предобработку (например, отрыть соединение к серверу)
    def __enter__(self):
        print("__enter__ called")
        self.state = "open"
        self.print_state("inside __enter__")
        return self

    def print_state(self, info):
        print(f"State: {self.state} {info}")

    # этот метод нужен чтобы сделать постобработку объекта (например, закрыть соединение к серверу)
    def __exit__(self, *args):
        print("__exit__ called")
        self.state = "closed"
        self.print_state("inside __exit__")

# MyContext() инициализирует объект класса MyContext
ctx = MyContext()
# with примененный к уже инициализированному контекстному менеджеру вызывает у него метод __enter__
with ctx as stateful:
    stateful.print_state("inside with")
# когда мы выходим из блока with, вызывается метод __exit__
stateful.print_state("outside with")
```

## Декораторы
Часто в коде Python вы увидите так называемые декораторы. В этом ничего сложного нет и это просто синтаксическое удобство. Дело в том, что функции в Python являются так называемыми *first-class* объектами, что означает, что их можно присваивать переменным, их можно передавать в качестве аргументов в функии, функции могут возвращать другие функции.

Давайте рассмотрим пример
```python
def generate_add_operator():
    def add(a, b):
        return a + b
    return add

operator = generate_add_operator()
result = operator(1, 2)
print(result)
```
В этом примере функция `generate_add_operator` определяет внутри себя функцию, которую и возвращает в качестве результата. Этот результат мы присваиваем переменной `operator` и поскольку эта переменная теперь содержит функцию, мы ее можем вызвать.

Давайте рассмотрим еще один пример
```python
def reverse_args(func):
    def rfunc(*args):
        return func(*reversed(args))
    return rfunc

def my_func(first, second):
    print(f"First: {first}, Second: {second}")

my_func(1, 2)
reversed_my_func = reverse_args(my_func)
reversed_my_func(1, 2)
```
В этом примере `reverse_args` принимает в качестве аргумента функцию. Далее внутри `reverse_args` определяется новая функция, в которой оригинальная функия вызывается с теми же аргументами, но в обратном порядке. Далее эта новая функция возвращается в качестве результата.

Теперь перейдем к примеру непосредственно с декоратором
```python
def reverse_args(func):
    def rfunc(*args):
        return func(*reversed(args))
    return rfunc

@reverse_args
def my_func(first, second):
    print(f"First: {first}, Second: {second}")

my_func(1, 2)
```
Здесь почти то же самое, только теперь ваша оригинальная функция будет перезаписана функцией с инвертированным порядком аргументов.

Вот это
```python
@reverse_args
def my_func(first, second):
    print(f"First: {first}, Second: {second}")
```

эквивалентно вот этому
```python
def my_func(first, second):
    print(f"First: {first}, Second: {second}")

my_func = reverse_args(my_func)
```

## Генераторы
Генераторы - это очень важное понятие в языке Python. Когда вы вызываете обычную функцию, то она выполняется от начала и до того, как в коде встречается слово `return` (или просто до конца функции, которая неявно возвращает `None`). После того как функция выполнилась, управление возвращается в место вызова функции, а локальные переменные функции удаляются (или по другому говорят разрушается контекст выполнения функции). Генератор - это функция, которая умеет прерывать свое выполнение и возвращать управление в место вызова, не разрушая контекст выполнения. То есть вы можете такую функцию вызвать снова и она продолжит свое выполнения с того места, где она остановилась в прошлый раз. Она будет останавливаться каждый раз, когда в коде встретится слово `yield`. Для того, чтобы вызывать генератор несколько раз используется интерфейс итератора (либо явно можно вызвать встроенную функцию `next` и передать в качестве аргумента генератор, либо просто проитерироваться по генератору при помощи `for`).

*Генераторы - это по своей сути корутины. Корутины - это более абстрактное и более общее понятие. Вообще корутины могут быть реализованы по разному и генераторы можно считать одной из специфических реализаций. Кстати генераторы могут не только возвращать данные, но и принимать (этот случай мы для простоты пока затрагивать не будем), но генераторы могут возвращать управление только в точку вызова, а корутина в общем случае может передать управление в произвольное место. Генераторы можно применять и для других случаев, которые никак не связаны с кооперативной многозадачностью.*

Давайте рассмотрим примеры
```python
# функция new_gen возвращает генератор
def new_gen():
    yield 1
    yield 2

# вызываем new_gen и результат ее выполнения (генератор) присваиваем переменной g
g = new_gen()
# еще раз вызываем и результат присваиваем переменной h
h = new_gen()

# давайте удостоверимся, что g и h генераторы
print(type(g))
print(type(h))

# давайте попробуем обратиться к генератору с помощью встроенной функции next
result = next(g)
# напечатется 1
print(result)
# еще раз то же самое
result = next(g)
# напечатается 2
print(result)
# теперь генератор g исчерпан, при вызове next он вернет исключение StopIteration
next(g)

# у нас все еще есть генератор h, давайте по нему проитерируемся
for i in h:
    print(i)

```

Для генераторов существует синтаксис, аналогичный list comprehension. Давайте рассмотрим вот такой пример.
```python
g = (item for item in [1, 2, 3])

print(type(g))

for i in g:
    print(i)

```

# Домашка 4

## Задача 1
В файле `<surname>/complex.py` реализовать класс ComplexNumber (комплексное число) такой, чтобы экземпляры этого класса можно было обычным образом складывать, вычитать, умножать, делить по правилам комплексных чисел. Зафиксируем следующий программный интерфейс:
    - В конструктор передаются действительная и мнимая части
    - Вызов функции str с экземпляром ComplexNumber должен возвращать строку вида "(X, Y)", где X и Y это действительная и мнимая части комплексного числа

**Важно:** Упомянутые операции должны быть реализованы так, чтобы можно было применить несколько операций в одной строке. Например

```python
# a, b, c - комплексные числа (экземпляры класса ComplexNumber)
a + b * d
```

**Подсказка:** Нужно реализовать следующие magic методы `__add__`, `__sub__`, `__mul__`, `__truediv__`, `__str__`.

## Задача 2
В файле `<surname>/probability.py` pеализовать класс ProbabilityMoments, экземпляр которого можно использовать как контекстный менеджер для вычисления моментов случайных величин (среднего и дисперсии). По-английски они называются `mean` и `variance`.

```python
class ProbabilityMoments:
    def __init__(self, filename):
        """Конструктор принимает в качестве аргумента имя файла в котором сохраняются некоторые параметры случайной величины.
        Вам нужно самим решить, что именно сохранять и в каком формате.
        """
        pass

    def __enter__(self):
        """При вызве этого метода, нужно вычитывать параметры из файла, заданного в конструкторе.
        """
        ...
        return self

    def __exit__(self, *args):
        """При вызове этого метода, нужно сохранять параметры в файл.
        """
        pass

    def add(self, x):
        """Добавить новое значение случайной величины к выборке.
        """
        pass

    def mean(self):
        """Вернуть среднее значение случайной величины на текущий момент.
        """
        pass

    def variance(self):
        """Вернуть дисперсию случайной величины на текущий момент.
        """
        pass
```

Пользоваться этим контекстным менеджером предполагается следующим образом.

```python
with ProbabilityMoments("distribution.json") as pm:
    for x in data:
        pm.add(x)
    print(pm.mean())
    print(pm.variance())
```

**Подсказка:** Для сохранения/вычитывания параметров в файл/из файла удобно использовать библиотеку `json`, которая хорошо работает для встроенных структур данных `dict` и `list`.

**Подсказка:** Оценить среднее значение случайной величины можно по формуле:
```math
\begin{equation}
\mu = \frac{\sum_{i=1}^N X_i}{N}
\end{equation}
```
Дисперсию можно оценить по следующей формуле:
```math
\begin{equation}
\sigma = \sqrt\frac{\sum_{i=1}^N (X_i - \mu)^2}{N}
\end{equation}
```

Ясно, что чем больше выборка (чем больше раз мы вызываем метод ProbabilityMoments.add), тем меньше ошибка при оценке моментов случайной величины.

Смысл в том, что вы можете получать данные периодически, например по 10 событий в день и вы можете запускать ваш `Python` скрипт, раз в день, натравливать его на файл, где у вас хранятся значения с предыдущего запуска и уточнять величины. Заметьте, что вам не обязательно хранить всю выборку в файле, это может занять большое пространство на диске.

## Задача 3

Рассмотрим некоторую систему функций, принимающих в качестве аргументов произвольные множества точек на плоскости в виде пар их декартовых координат `(x, y)`. Функции делают какие-то вычисления, смысл которых нам не важен. Это могут быть вычисления кластеров точек, могут быть вычисления связанные с динамикой точек и т.д.

Нам нужно реализовать декораторы, задающие преобразования координат этих точек
  - shift - задает смещение точек на определенный вектор. Смещение задается радиус вектором, то есть парой декартовых координат `(x, y)`
  - reflect - отражает все точки относительно начала координат
  - rotate - поворачивает все точки, на угол $\phi$ относительно начала координат

Допустим у нас есть функция, вычисляющая по N точкам некотрую величину

```python
# функция принимает произвольное количество аргументов пар (X, Y)
def compute(*args):
    pass
```

Нужно, чтобы мы могли при помощи декораторов переопределить эту функцию так, чтобы она делала вычисления для точек, в повернутой, сдвинутой или отраженной системе коородинат

Например так:

```python
@rotate(90)
def compute(*args):
    pass
```

или так:

```python
@shift(1.0, 3.0)
@reflect
def compute(*args):
    pass
```

**Важно:** Обратите внимание, что rotate и shift должны быть не декораторами, а функциями, принимающими параметры и возвращающими декораторы.

**Подсказка:** Для реализации декоратора rotate вспомните, что вращения на плоскости задаются ортогональными матрицами. Например вращение на угол $\phi$ задается матрицей
```math
\begin{pmatrix}
\cos\phi & -\sin\phi\\
\sin\phi & \cos\phi
\end{pmatrix}
```
Для вычисления функций $sin$ и $cos$ можно использовать встроенную библиотеку `math`
```python
import math
math.sin(0.0)
```
